<div style="position: fixed;">
    <label for="simulation-speed">speed</label>
    <input type="range" id="simulation-speed" min="1.5" max="100" value="30">
    <br>
    <label for="radius-detection-range">radius-detection-range</label>
    <input type="range" id="radius-detection-range" min="1" max="100" value="30">

    <p>FPS: <span id="fps-counter">-</span></p>
    <p>Objects: <span id="objects-count">-</span></p>
    <p>Total Momentum: <span id="total-momentum">-</span></p>
</div>
<canvas id="canvas"></canvas>
<script>
    let lastFrameTime = Date.now();
    let currentFrameTime = Date.now();
    let fpsAccum = 0;
    let totalFps = 0;

    const objectsCount = document.getElementById('objects-count');
    const totalMomentum = document.getElementById('total-momentum');
    const fpsCounter = document.getElementById('fps-counter');
    const radiusDetectionRangeElement = document.getElementById('radius-detection-range');
    const simulationSpeedElement = document.getElementById('simulation-speed');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1750;
    canvas.height = 750;
    let radiusDetectionRange = Number(radiusDetectionRangeElement.value);
    let simulationSpeed = Number(simulationSpeedElement.value);

    // const spaceObjects = [
    //     {position: {x: 700, y: 350}, moment: {x: 0, y: 0}, mass: 1024}, // neptune
    //     {position: {x: 700, y: 300}, moment: {x: 0, y: 0}, mass: 868}, // uranus
    // ].map(object => ({
    //     ...object,
    //     prevPosition: object.position,
    //     color: {g: Math.floor(Math.random() * 200), b: Math.floor(Math.random() * 200)}
    // }));

    let spaceObjects = [];

    const distanceBetween = 30;
    for (let i = distanceBetween; i < canvas.width - 1; i += distanceBetween) {
        for (let j = distanceBetween; j < canvas.height - 1; j += distanceBetween) {
            spaceObjects.push({
                prevPosition: {x: i, y: j},
                position: {x: i, y: j},
                moment: {x: 0, y: 0},
                mass: Math.random() * 2000000,
                // mass: 10000,
                color: {g: Math.floor(Math.random() * 200), b: Math.floor(Math.random() * 200)}
            });
        }
    }

    const drawSpaceObjects = () => {
        const debugNow = Date.now();
        for (let i = 0; i < spaceObjects.length; i++) {
            const x = spaceObjects[i].position.x;
            const y = spaceObjects[i].position.y;
            const size = 3;

            const color = Math.min(255, Math.sqrt(spaceObjects[i].moment.x ** 2 + spaceObjects[i].moment.y ** 2) / 20 * 255);
            //requestAnimationFrame(() => {
            ctx.strokeStyle = ctx.fillStyle = 'rgb(' + color + ', ' + spaceObjects[i].color.g + ', ' + spaceObjects[i].color.b + ')';

            ctx.lineWidth = size;
            ctx.beginPath();
            // ctx.moveTo(spaceObjects[i].prevPosition.x - size / 2, spaceObjects[i].prevPosition.y - size / 2);
            ctx.lineTo(x - size / 2, y - size / 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(x - size / 2, y - size / 2, size / 2, 0, 2 * Math.PI);
            ctx.fill();
            //});
        }
        console.log('drawSpaceObjects: ' + (Date.now() - debugNow) + 'ms');
    };

    const updateSpaceObjectsPosition = () => {
        const debugNow = Date.now();
        const speed = 3 - (3 / Math.sqrt(simulationSpeed));

        for (let i = 0; i < spaceObjects.length; i++) {
            spaceObjects[i].prevPosition.x = spaceObjects[i].position.x;
            spaceObjects[i].prevPosition.y = spaceObjects[i].position.y;
            spaceObjects[i].position.x += speed * spaceObjects[i].moment.x;
            spaceObjects[i].position.y += speed * spaceObjects[i].moment.y;
        }
        console.log('updateSpaceObjectsPosition: ' + (Date.now() - debugNow) + 'ms');
    };

    const updateSpaceObjectsMoment = () => {
        const debugNow = Date.now();
        const spaceObjectsAmount = spaceObjects.length;
        const radiusDetectionRangeRate = 0.3 + 8 - 8 / radiusDetectionRange;

        // let isCollided = false;
        // let collidedParams = {dx: 0, dy: 0};
        for (let i = 0; i < spaceObjectsAmount; i++) {
            const rootObject = spaceObjects[i];

            let resultVector = {x: 0, y: 0};

            for (let j = 0; j < spaceObjectsAmount; j++) {
                if (i === j) continue;
                const dy = rootObject.position.y - spaceObjects[j].position.y;
                const dx = rootObject.position.x - spaceObjects[j].position.x;

                const distance = Math.sqrt(dy * dy + dx * dx);

                let a, x, y;
                if (distance <= 2) {

                    break;
                }
                // if (distance <= radiusDetectionRangeRate) {
                //     resultVector.x += 0;
                //     resultVector.y += 0;
                //     break;
                // }
                // spaceObjects.push({
                //     ...rootObject,
                //     moment: {
                //         x: rootObject.mass > spaceObjects[j].mass ? rootObject.moment.x : spaceObjects[j].moment.x,
                //         y: rootObject.mass > spaceObjects[j].mass ? rootObject.moment.y : spaceObjects[j].moment.y
                //     },
                //     mass: rootObject.mass + spaceObjects[j].mass,
                //     color: {g: Math.floor(Math.random() * 200), b: Math.floor(Math.random() * 200)}
                // });
                // spaceObjects = spaceObjects.filter((_, index) => index !== i && index !== j);
                // spaceObjects.splice(i, 1);
                // spaceObjects.splice(j, 1);
                //isCollided = true;
                //break;
                // const test = Math.max(Math.abs(dy), Math.abs(dx));
                // x = (dx === 0 || !isFinite(dx)) ? 0 : dx / test;
                // y = (dy === 0 || !isFinite(dy)) ? 0 : dy / test;
                //
                // collidedParams.dx = x;
                // collidedParams.dy = y;
                //break;
                // } else {
                a = 0.1 * spaceObjects[j].mass / (distance * distance); // 1 and 2 newton's laws
                if (a > 100) a = 100 / 2;

                const test = Math.max(Math.abs(dy), Math.abs(dx));
                x = (dx === 0 || !isFinite(dx)) ? 0 : dx / test;
                y = (dy === 0 || !isFinite(dy)) ? 0 : dy / test;
                // }

                resultVector.x += -a * x;
                resultVector.y += -a * y;
            }

            // if (isCollided) {
            //     continue;
            // } else {
            resultVector = {y: resultVector.y / spaceObjectsAmount, x: resultVector.x / spaceObjectsAmount};

            rootObject.moment.x += resultVector.x;
            rootObject.moment.y += resultVector.y;

            rootObject.moment.x *= 0.999;
            rootObject.moment.y *= 0.999;
            // }
        }

        console.log('updateSpaceObjectsMoment: ' + (Date.now() - debugNow) + 'ms');
    };

    const clearObjects = () => {
        const offsetBuffer = -10;

        for (let i = 0; i < spaceObjects.length; i++) {
            if (spaceObjects[i].position.x < -offsetBuffer) {
                spaceObjects[i].moment.x = Math.abs(spaceObjects[i].moment.x) * 0.5;
            } else if (spaceObjects[i].position.x > canvas.width + offsetBuffer) {
                spaceObjects[i].moment.x = -Math.abs(spaceObjects[i].moment.x) * 0.5;
            }

            if (spaceObjects[i].position.y < -offsetBuffer) {
                spaceObjects[i].moment.y = Math.abs(spaceObjects[i].moment.y) * 0.5;
            } else if (spaceObjects[i].position.y > canvas.height + offsetBuffer) {
                spaceObjects[i].moment.y = -Math.abs(spaceObjects[i].moment.y) * 0.5;
            }

            // if (spaceObjects[i].position.x < -1000 || spaceObjects[i].position.y < -1000
            //     || spaceObjects[i].position.x > 3000 || spaceObjects[i].position.y > 3000) {
            //     spaceObjects[i].spaceObjects = spaceObjects.filter((_, index) => index !== i);
            // }
        }
    };

    const drawMap = () => {
        ctx.fillStyle = 'rgba(255,255,255, 1.00)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    };

    setInterval(() => {
        currentFrameTime = Date.now();
        const deltaFrameTime = currentFrameTime - lastFrameTime

        lastFrameTime = currentFrameTime;
        totalFps += deltaFrameTime;

        if (totalFps > 1000) {
            fpsCounter.innerHTML = fpsAccum;
            fpsAccum = 0;
            totalFps = 0;
        } else {
            fpsAccum++;
        }

        objectsCount.innerHTML = spaceObjects.length;
        totalMomentum.innerHTML = parseInt(spaceObjects.reduce((acc, object) => acc + Math.sqrt(object.moment.x ** 2 + object.moment.y ** 2), 0));
        clearObjects();
        drawMap();
        updateSpaceObjectsMoment();
        updateSpaceObjectsPosition();
        drawSpaceObjects();
    }, 0);

    radiusDetectionRangeElement.addEventListener('input', e => {
        radiusDetectionRange = Number(e.target.value);
    });

    simulationSpeedElement.addEventListener('input', e => {
        simulationSpeed = Number(e.target.value);
    });

    document.addEventListener('keyup', e => {
        if (e.keyCode === 32) {

        }
    });

    canvas.addEventListener('mouseup', e => {
        const x = e.clientX;
        const y = e.clientY;

        spaceObjects.push({
            prevPosition: {x: x, y: y},
            position: {x: x, y: y},
            moment: {x: 0, y: 0},
            mass: Math.random() * 2000000,
            // mass: 1000000000000,
            color: {g: Math.floor(Math.random() * 200), b: Math.floor(Math.random() * 200)}
        });
        e.clientX
        e.clientY
    });
</script>